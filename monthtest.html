/**
 * @OnlyCurrentDoc
 */

// 將所有常數定義在腳本的最頂部，確保全域可訪問
const SHEET_ID = '1IJQpGWxGOHy3C7kdewtaKANir1JmX9xZQqyqAYuDYX8'; // 您的試算表ID
const DOC_ID = '1WAJ9AN48LnsqiW38Bfax4qZkmKt67I6vtJ5sQgRHG9c';   // 您的文件ID
const SHEET_NAME = '工作表1'; // 您的工作表名稱

// PDF 暫存資料夾名稱
const TEMP_FOLDER_NAME = '客戶資料轉移PDF暫存';

// 定義試算表欄位與Google文件表格單元格的映射關係
const MAPPING = {
  '客編': { tableIndex: 0, rowIndex: 1, colIndex: 1, placeholder: '{{客編}}' },
  '姓名': { tableIndex: 0, rowIndex: 1, colIndex: 9, placeholder: '{{姓名}}' },
  '地址': { tableIndex: 0, rowIndex: 2, colIndex: 1, placeholder: '{{地址}}' },
  '新客編': { tableIndex: 0, rowIndex: 4, colIndex: 1, placeholder: '{{新客編}}' },
  '新姓名': { tableIndex: 0, rowIndex: 4, colIndex: 9, placeholder: '{{新姓名}}' },
  '新地址': { tableIndex: 0, rowIndex: 5, colIndex: 1, placeholder: '{{新地址}}' },
  '轉移區間': { tableIndex: 0, rowIndex: 6, colIndex: 1, placeholder: '{{轉移區間}}' },
  '轉移時間': { tableIndex: 0, rowIndex: 6, colIndex: 9, placeholder: '{{轉移時間}}' },
  '轉移後到期日': { tableIndex: 0, rowIndex: 7, colIndex: 1, placeholder: '{{轉移後到期日}}' }
};

/**
 * 當試算表被編輯時自動觸發，用最新一列的資料更新文件中的指定表格單元格。
 */
function onEdit(e) {
  if (!e || !e.range) {
    console.log("此函式應由onEdit觸發器自動執行，而非手動運行。");
    return;
  }

  const editedSheet = e.range.getSheet();
  if (editedSheet.getName() === SHEET_NAME) {
    try {
      const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
      const lastRow = sheet.getLastRow();

      if (lastRow >= 2) {
        const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
        const dataRow = sheet.getRange(lastRow, 1, 1, sheet.getLastColumn()).getValues()[0];
        
        console.log('Headers: ' + headers);
        console.log('Data Row: ' + dataRow);

        updateDocumentWithData(headers, dataRow);
      }
    } catch (error) {
      console.log('onEdit 執行過程中發生錯誤：' + error.toString());
    }
  }
}

/**
 * Web App 的 doPost 函式，用於接收來自網頁的 POST 請求
 */
function doPost(e) {
  try {
    const response = {
      success: false,
      message: '',
      data: null
    };

    // 解析請求內容
    let requestData;
    if (e.postData && e.postData.contents) {
      try {
        requestData = JSON.parse(e.postData.contents);
      } catch (parseError) {
        response.message = '無法解析請求資料：' + parseError.toString();
        return ContentService.createTextOutput(JSON.stringify(response))
          .setMimeType(ContentService.MimeType.JSON);
      }
    } else {
      response.message = '未收到請求資料';
      return ContentService.createTextOutput(JSON.stringify(response))
        .setMimeType(ContentService.MimeType.JSON);
    }

    console.log('收到來自網頁的資料：', JSON.stringify(requestData));

    // 檢查請求類型
    if (requestData.action === 'sendPDF') {
      // 處理發送 PDF 的請求
      const result = sendPDFToEmail(requestData.email, requestData.pdfFileId);
      
      if (result.success) {
        response.success = true;
        response.message = 'PDF 已成功發送到您的 Email';
        response.data = result.data;
      } else {
        response.message = '發送 PDF 時發生錯誤：' + result.message;
      }
    } else {
      // 處理一般的資料提交請求（包含 PDF 預覽生成）
      const result = writeDataToSheetAndGeneratePreview(requestData);
      
      if (result.success) {
        response.success = true;
        response.message = '資料已成功寫入試算表並生成 PDF 預覽';
        response.data = result.data;
      } else {
        response.message = '處理資料時發生錯誤：' + result.message;
      }
    }

    return ContentService.createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON);

  } catch (error) {
    console.log('doPost 執行過程中發生錯誤：' + error.toString());
    const errorResponse = {
      success: false,
      message: 'Web App 執行錯誤：' + error.toString(),
      data: null
    };

    return ContentService.createTextOutput(JSON.stringify(errorResponse))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * Web App 的 doGet 函式，用於處理 GET 請求
 */
function doGet(e) {
  const response = {
    success: true,
    message: 'Web App 運行正常',
    timestamp: new Date().toISOString(),
    version: 'Enhanced with PDF Preview v1.0'
  };

  return ContentService.createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * 將來自網頁的資料寫入 Google 試算表並生成 PDF 預覽
 */
function writeDataToSheetAndGeneratePreview(data) {
  try {
    // 1. 寫入試算表
    const sheetResult = writeDataToSheet(data);
    if (!sheetResult.success) {
      return sheetResult;
    }

    // 2. 更新文件
    const headers = Object.keys(MAPPING);
    const dataRow = headers.map(header => data[header] || '');
    updateDocumentWithData(headers, dataRow);

    // 3. 生成 PDF 預覽
    const pdfResult = generatePDFPreview();
    if (!pdfResult.success) {
      return pdfResult;
    }

    return {
      success: true,
      message: '資料已成功寫入試算表並生成 PDF 預覽',
      data: {
        sheet: sheetResult.data,
        pdf: pdfResult.data
      }
    };
    
  } catch (error) {
    console.log('writeDataToSheetAndGeneratePreview 執行過程中發生錯誤：' + error.toString());
    return {
      success: false,
      message: error.toString(),
      data: null
    };
  }
}

/**
 * 將來自網頁的資料寫入 Google 試算表
 */
function writeDataToSheet(data) {
  try {
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheetByName(SHEET_NAME);
    
    // 獲取標題列
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // 準備要寫入的資料列
    const newRow = [];
    
    // 根據標題列的順序，從 data 中提取對應的值
    for (const header of headers) {
      if (data.hasOwnProperty(header)) {
        newRow.push(data[header]);
      } else {
        newRow.push(''); // 如果沒有對應的資料，則填入空字串
      }
    }
    
    // 將資料寫入試算表的新列
    const nextRow = sheet.getLastRow() + 1;
    sheet.getRange(nextRow, 1, 1, newRow.length).setValues([newRow]);
    
    console.log('資料已成功寫入試算表第 ' + nextRow + ' 列：', newRow);
    
    return {
      success: true,
      message: '資料已成功寫入試算表',
      data: {
        row: nextRow,
        values: newRow
      }
    };
    
  } catch (error) {
    console.log('writeDataToSheet 執行過程中發生錯誤：' + error.toString());
    return {
      success: false,
      message: error.toString(),
      data: null
    };
  }
}

/**
 * 使用新資料更新 Google 文件
 */
function updateDocumentWithData(headers, dataRow) {
  try {
    const doc = DocumentApp.openById(DOC_ID);
    const body = doc.getBody();
    const tables = body.getTables();

    if (tables.length === 0) {
      console.log('文件中沒有找到任何表格。');
      return;
    }

    let updatedCount = 0;

    for (const header of headers) {
      if (MAPPING[header]) {
        const map = MAPPING[header];
        const replacementText = dataRow[headers.indexOf(header)] !== undefined && dataRow[headers.indexOf(header)] !== null ? String(dataRow[headers.indexOf(header)]) : '';

        if (tables[map.tableIndex]) {
          const table = tables[map.tableIndex];
          if (table.getNumRows() > map.rowIndex && table.getRow(map.rowIndex).getNumCells() > map.colIndex) {
            const cell = table.getCell(map.rowIndex, map.colIndex);
            cell.setText(replacementText);
            console.log(`成功將表格 [${map.tableIndex}][${map.rowIndex}][${map.colIndex}] 更新為: ${replacementText}`);
            updatedCount++;
          } else {
            console.log(`表格 [${map.tableIndex}] 的行或列索引超出範圍: 行 ${map.rowIndex}, 列 ${map.colIndex}`);
          }
        } else {
          console.log(`未找到表格索引為 ${map.tableIndex} 的表格。`);
        }
      }
    }

    doc.saveAndClose();
    if (updatedCount > 0) {
      console.log('文件更新成功！');
    } else {
      console.log('沒有找到對應的欄位進行更新。');
    }
  } catch (error) {
    console.log('updateDocumentWithData 執行過程中發生錯誤：' + error.toString());
  }
}

/**
 * 生成 PDF 預覽
 * @return {object} - 包含成功狀態、預覽連結等資訊的物件
 */
function generatePDFPreview() {
  try {
    console.log('開始生成 PDF 預覽');

    // 獲取或創建暫存資料夾
    const tempFolder = getOrCreateTempFolder();
    
    // 獲取 Google 文件
    const docFile = DriveApp.getFileById(DOC_ID);
    
    // 將文件轉換為 PDF
    const pdfBlob = docFile.getAs('application/pdf');
    
    // 設定 PDF 檔案名稱（包含時間戳記和隨機字串）
    const timestamp = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd_HH-mm-ss');
    const randomId = Utilities.getUuid().substring(0, 8);
    const pdfFileName = `客戶資料轉移文件_${timestamp}_${randomId}.pdf`;
    pdfBlob.setName(pdfFileName);

    // 將 PDF 儲存到暫存資料夾
    const pdfFile = tempFolder.createFile(pdfBlob);
    
    // 設定檔案權限為「知道連結的人可以檢視」
    pdfFile.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
    // 獲取預覽連結
    const previewUrl = `https://drive.google.com/file/d/${pdfFile.getId()}/preview`;
    const downloadUrl = `https://drive.google.com/uc?id=${pdfFile.getId()}&export=download`;

    console.log('PDF 預覽已生成，檔案 ID:', pdfFile.getId());

    // 設定檔案 24 小時後自動刪除（透過觸發器）
    scheduleFileCleanup(pdfFile.getId());

    return {
      success: true,
      message: 'PDF 預覽已生成',
      data: {
        fileId: pdfFile.getId(),
        fileName: pdfFileName,
        previewUrl: previewUrl,
        downloadUrl: downloadUrl,
        timestamp: timestamp,
        expiresIn: '24 小時'
      }
    };

  } catch (error) {
    console.log('generatePDFPreview 執行過程中發生錯誤：' + error.toString());
    return {
      success: false,
      message: error.toString(),
      data: null
    };
  }
}

/**
 * 發送 PDF 到指定 Email
 * @param {string} email - 收件人的 Email 地址
 * @param {string} pdfFileId - PDF 檔案的 Drive ID
 * @return {object} - 包含成功狀態和訊息的物件
 */
function sendPDFToEmail(email, pdfFileId) {
  try {
    // 驗證 Email 格式
    if (!email || !isValidEmail(email)) {
      return {
        success: false,
        message: '請提供有效的 Email 地址',
        data: null
      };
    }

    // 驗證 PDF 檔案 ID
    if (!pdfFileId) {
      return {
        success: false,
        message: '未提供 PDF 檔案 ID',
        data: null
      };
    }

    console.log('開始發送 PDF 到：' + email + '，檔案 ID：' + pdfFileId);

    // 獲取 PDF 檔案
    let pdfFile;
    try {
      pdfFile = DriveApp.getFileById(pdfFileId);
    } catch (fileError) {
      return {
        success: false,
        message: 'PDF 檔案不存在或已過期',
        data: null
      };
    }
    
    // 獲取 PDF Blob
    const pdfBlob = pdfFile.getBlob();

    // 發送 Email
    const emailSubject = '客戶資料轉移文件';
    const emailBody = `
親愛的用戶，

您好！

請查收附件中的客戶資料轉移文件 PDF。

此文件包含了您最新提交的客戶資料轉移資訊。

如有任何問題，請隨時與我們聯繫。

謝謝！

---
此郵件由系統自動發送，請勿直接回覆。
生成時間：${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy年MM月dd日 HH:mm:ss')}
    `;

    MailApp.sendEmail({
      to: email,
      subject: emailSubject,
      body: emailBody,
      attachments: [pdfBlob]
    });

    console.log('PDF 已成功發送到：' + email);

    // 發送成功後，可以選擇刪除暫存檔案
    // pdfFile.setTrashed(true);

    return {
      success: true,
      message: 'PDF 已成功發送',
      data: {
        email: email,
        fileName: pdfFile.getName(),
        timestamp: Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm:ss')
      }
    };

  } catch (error) {
    console.log('sendPDFToEmail 執行過程中發生錯誤：' + error.toString());
    return {
      success: false,
      message: error.toString(),
      data: null
    };
  }
}

/**
 * 獲取或創建暫存資料夾
 * @return {Folder} - Google Drive 資料夾物件
 */
function getOrCreateTempFolder() {
  try {
    // 先嘗試找到現有的暫存資料夾
    const folders = DriveApp.getFoldersByName(TEMP_FOLDER_NAME);
    
    if (folders.hasNext()) {
      return folders.next();
    } else {
      // 如果不存在，則創建新的暫存資料夾
      const tempFolder = DriveApp.createFolder(TEMP_FOLDER_NAME);
      console.log('已創建暫存資料夾：' + TEMP_FOLDER_NAME);
      return tempFolder;
    }
  } catch (error) {
    console.log('getOrCreateTempFolder 執行過程中發生錯誤：' + error.toString());
    throw error;
  }
}

/**
 * 排程檔案清理（24 小時後刪除）
 * @param {string} fileId - 要刪除的檔案 ID
 */
function scheduleFileCleanup(fileId) {
  try {
    // 創建一個 24 小時後執行的觸發器
    const trigger = ScriptApp.newTrigger('cleanupTempFile')
      .timeBased()
      .after(24 * 60 * 60 * 1000) // 24 小時（毫秒）
      .create();
    
    // 將檔案 ID 儲存到 PropertiesService 中，以便觸發器執行時使用
    const properties = PropertiesService.getScriptProperties();
    properties.setProperty(`cleanup_${trigger.getUniqueId()}`, fileId);
    
    console.log('已排程檔案清理，觸發器 ID：' + trigger.getUniqueId());
  } catch (error) {
    console.log('scheduleFileCleanup 執行過程中發生錯誤：' + error.toString());
  }
}

/**
 * 清理暫存檔案（由觸發器調用）
 * @param {object} e - 觸發器事件物件
 */
function cleanupTempFile(e) {
  try {
    const triggerId = e.triggerUid;
    const properties = PropertiesService.getScriptProperties();
    const fileId = properties.getProperty(`cleanup_${triggerId}`);
    
    if (fileId) {
      try {
        const file = DriveApp.getFileById(fileId);
        file.setTrashed(true);
        console.log('已刪除暫存檔案：' + fileId);
      } catch (fileError) {
        console.log('檔案可能已被刪除：' + fileId);
      }
      
      // 清理 Properties
      properties.deleteProperty(`cleanup_${triggerId}`);
    }
    
    // 刪除觸發器
    const triggers = ScriptApp.getProjectTriggers();
    for (const trigger of triggers) {
      if (trigger.getUniqueId() === triggerId) {
        ScriptApp.deleteTrigger(trigger);
        break;
      }
    }
    
  } catch (error) {
    console.log('cleanupTempFile 執行過程中發生錯誤：' + error.toString());
  }
}

/**
 * 手動清理所有暫存檔案（管理用）
 */
function cleanupAllTempFiles() {
  try {
    const folders = DriveApp.getFoldersByName(TEMP_FOLDER_NAME);
    
    if (folders.hasNext()) {
      const tempFolder = folders.next();
      const files = tempFolder.getFiles();
      let deletedCount = 0;
      
      while (files.hasNext()) {
        const file = files.next();
        file.setTrashed(true);
        deletedCount++;
      }
      
      console.log(`已清理 ${deletedCount} 個暫存檔案`);
      return `已清理 ${deletedCount} 個暫存檔案`;
    } else {
      console.log('未找到暫存資料夾');
      return '未找到暫存資料夾';
    }
  } catch (error) {
    console.log('cleanupAllTempFiles 執行過程中發生錯誤：' + error.toString());
    return '清理失敗：' + error.toString();
  }
}

/**
 * 驗證 Email 格式
 * @param {string} email - 要驗證的 Email 地址
 * @return {boolean} - 是否為有效的 Email 格式
 */
function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * 手動執行此函式，將文件中的指定表格單元格內容恢復為佔位符。
 */
function restorePlaceholders() {
  try {
    const doc = DocumentApp.openById(DOC_ID);
    const body = doc.getBody();
    const tables = body.getTables();

    if (tables.length === 0) {
      console.log('文件中沒有找到任何表格。');
      SpreadsheetApp.getUi().alert('恢復失敗：文件中沒有找到任何表格。');
      return;
    }

    let restoredCount = 0;

    for (const header in MAPPING) {
      const map = MAPPING[header];
      const placeholder = map.placeholder;

      if (tables[map.tableIndex]) {
        const table = tables[map.tableIndex];
        if (table.getNumRows() > map.rowIndex && table.getRow(map.rowIndex).getNumCells() > map.colIndex) {
          const cell = table.getCell(map.rowIndex, map.colIndex);
          cell.setText(placeholder);
          console.log(`成功將表格 [${map.tableIndex}][${map.rowIndex}][${map.colIndex}] 恢復為佔位符: ${placeholder}`);
          restoredCount++;
        } else {
          console.log(`表格 [${map.tableIndex}] 的行或列索引超出範圍: 行 ${map.rowIndex}, 列 ${map.colIndex}`);
        }
      }
    }

    doc.saveAndClose();
    if (restoredCount > 0) {
      console.log('佔位符恢復成功！');
      SpreadsheetApp.getUi().alert('佔位符恢復成功！');
    } else {
      console.log('沒有找到對應的欄位進行恢復。');
      SpreadsheetApp.getUi().alert('恢復失敗：沒有找到對應的欄位進行恢復。');
    }
  } catch (error) {
    console.log('restorePlaceholders 執行過程中發生錯誤：' + error.toString());
    SpreadsheetApp.getUi().alert('恢復失敗：' + error.toString());
  }
}

/**
 * 測試 PDF 預覽功能（手動執行用）
 */
function testPDFPreview() {
  const result = generatePDFPreview();
  
  if (result.success) {
    console.log('測試成功：' + result.message);
    console.log('預覽連結：' + result.data.previewUrl);
  } else {
    console.log('測試失敗：' + result.message);
  }
  
  return result;
}


























